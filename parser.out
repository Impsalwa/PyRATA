Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> expression
Rule 1     expression -> quantifiedstep expression
Rule 2     expression -> quantifiedstep
Rule 3     quantifiedstep -> step
Rule 4     quantifiedstep -> OPTION step
Rule 5     quantifiedstep -> ATLEASTONE step
Rule 6     quantifiedstep -> ANY step
Rule 7     step -> atomicconstraint
Rule 8     step -> NOT step
Rule 9     step -> LBRACKET classconstraint RBRACKET
Rule 10    classconstraint -> partofclassconstraint
Rule 11    classconstraint -> partofclassconstraint AND classconstraint
Rule 12    classconstraint -> partofclassconstraint OR classconstraint
Rule 13    partofclassconstraint -> atomicconstraint
Rule 14    partofclassconstraint -> LPAREN classconstraint RPAREN
Rule 15    partofclassconstraint -> NOT classconstraint
Rule 16    atomicconstraint -> NAME IS VALUE

Terminals, with rules where they appear

AND                  : 11
ANY                  : 6
ATLEASTONE           : 5
IS                   : 16
LBRACKET             : 9
LPAREN               : 14
NAME                 : 16
NOT                  : 8 15
OPTION               : 4
OR                   : 12
RBRACKET             : 9
RPAREN               : 14
VALUE                : 16
error                : 

Nonterminals, with rules where they appear

atomicconstraint     : 7 13
classconstraint      : 9 11 12 14 15
expression           : 1 0
partofclassconstraint : 10 11 12
quantifiedstep       : 1 2
step                 : 3 4 5 6 8

Parsing method: LALR

state 0

    (0) S' -> . expression
    (1) expression -> . quantifiedstep expression
    (2) expression -> . quantifiedstep
    (3) quantifiedstep -> . step
    (4) quantifiedstep -> . OPTION step
    (5) quantifiedstep -> . ATLEASTONE step
    (6) quantifiedstep -> . ANY step
    (7) step -> . atomicconstraint
    (8) step -> . NOT step
    (9) step -> . LBRACKET classconstraint RBRACKET
    (16) atomicconstraint -> . NAME IS VALUE

    OPTION          shift and go to state 9
    ATLEASTONE      shift and go to state 5
    ANY             shift and go to state 3
    NOT             shift and go to state 10
    LBRACKET        shift and go to state 6
    NAME            shift and go to state 4

    step                           shift and go to state 2
    quantifiedstep                 shift and go to state 8
    atomicconstraint               shift and go to state 7
    expression                     shift and go to state 1

state 1

    (0) S' -> expression .



state 2

    (3) quantifiedstep -> step .

    OPTION          reduce using rule 3 (quantifiedstep -> step .)
    ATLEASTONE      reduce using rule 3 (quantifiedstep -> step .)
    ANY             reduce using rule 3 (quantifiedstep -> step .)
    NOT             reduce using rule 3 (quantifiedstep -> step .)
    LBRACKET        reduce using rule 3 (quantifiedstep -> step .)
    NAME            reduce using rule 3 (quantifiedstep -> step .)
    $end            reduce using rule 3 (quantifiedstep -> step .)


state 3

    (6) quantifiedstep -> ANY . step
    (7) step -> . atomicconstraint
    (8) step -> . NOT step
    (9) step -> . LBRACKET classconstraint RBRACKET
    (16) atomicconstraint -> . NAME IS VALUE

    NOT             shift and go to state 10
    LBRACKET        shift and go to state 6
    NAME            shift and go to state 4

    step                           shift and go to state 11
    atomicconstraint               shift and go to state 7

state 4

    (16) atomicconstraint -> NAME . IS VALUE

    IS              shift and go to state 12


state 5

    (5) quantifiedstep -> ATLEASTONE . step
    (7) step -> . atomicconstraint
    (8) step -> . NOT step
    (9) step -> . LBRACKET classconstraint RBRACKET
    (16) atomicconstraint -> . NAME IS VALUE

    NOT             shift and go to state 10
    LBRACKET        shift and go to state 6
    NAME            shift and go to state 4

    step                           shift and go to state 13
    atomicconstraint               shift and go to state 7

state 6

    (9) step -> LBRACKET . classconstraint RBRACKET
    (10) classconstraint -> . partofclassconstraint
    (11) classconstraint -> . partofclassconstraint AND classconstraint
    (12) classconstraint -> . partofclassconstraint OR classconstraint
    (13) partofclassconstraint -> . atomicconstraint
    (14) partofclassconstraint -> . LPAREN classconstraint RPAREN
    (15) partofclassconstraint -> . NOT classconstraint
    (16) atomicconstraint -> . NAME IS VALUE

    LPAREN          shift and go to state 15
    NOT             shift and go to state 18
    NAME            shift and go to state 4

    classconstraint                shift and go to state 14
    atomicconstraint               shift and go to state 16
    partofclassconstraint          shift and go to state 17

state 7

    (7) step -> atomicconstraint .

    OPTION          reduce using rule 7 (step -> atomicconstraint .)
    ATLEASTONE      reduce using rule 7 (step -> atomicconstraint .)
    ANY             reduce using rule 7 (step -> atomicconstraint .)
    NOT             reduce using rule 7 (step -> atomicconstraint .)
    LBRACKET        reduce using rule 7 (step -> atomicconstraint .)
    NAME            reduce using rule 7 (step -> atomicconstraint .)
    $end            reduce using rule 7 (step -> atomicconstraint .)


state 8

    (1) expression -> quantifiedstep . expression
    (2) expression -> quantifiedstep .
    (1) expression -> . quantifiedstep expression
    (2) expression -> . quantifiedstep
    (3) quantifiedstep -> . step
    (4) quantifiedstep -> . OPTION step
    (5) quantifiedstep -> . ATLEASTONE step
    (6) quantifiedstep -> . ANY step
    (7) step -> . atomicconstraint
    (8) step -> . NOT step
    (9) step -> . LBRACKET classconstraint RBRACKET
    (16) atomicconstraint -> . NAME IS VALUE

    $end            reduce using rule 2 (expression -> quantifiedstep .)
    OPTION          shift and go to state 9
    ATLEASTONE      shift and go to state 5
    ANY             shift and go to state 3
    NOT             shift and go to state 10
    LBRACKET        shift and go to state 6
    NAME            shift and go to state 4

    step                           shift and go to state 2
    expression                     shift and go to state 19
    atomicconstraint               shift and go to state 7
    quantifiedstep                 shift and go to state 8

state 9

    (4) quantifiedstep -> OPTION . step
    (7) step -> . atomicconstraint
    (8) step -> . NOT step
    (9) step -> . LBRACKET classconstraint RBRACKET
    (16) atomicconstraint -> . NAME IS VALUE

    NOT             shift and go to state 10
    LBRACKET        shift and go to state 6
    NAME            shift and go to state 4

    step                           shift and go to state 20
    atomicconstraint               shift and go to state 7

state 10

    (8) step -> NOT . step
    (7) step -> . atomicconstraint
    (8) step -> . NOT step
    (9) step -> . LBRACKET classconstraint RBRACKET
    (16) atomicconstraint -> . NAME IS VALUE

    NOT             shift and go to state 10
    LBRACKET        shift and go to state 6
    NAME            shift and go to state 4

    step                           shift and go to state 21
    atomicconstraint               shift and go to state 7

state 11

    (6) quantifiedstep -> ANY step .

    OPTION          reduce using rule 6 (quantifiedstep -> ANY step .)
    ATLEASTONE      reduce using rule 6 (quantifiedstep -> ANY step .)
    ANY             reduce using rule 6 (quantifiedstep -> ANY step .)
    NOT             reduce using rule 6 (quantifiedstep -> ANY step .)
    LBRACKET        reduce using rule 6 (quantifiedstep -> ANY step .)
    NAME            reduce using rule 6 (quantifiedstep -> ANY step .)
    $end            reduce using rule 6 (quantifiedstep -> ANY step .)


state 12

    (16) atomicconstraint -> NAME IS . VALUE

    VALUE           shift and go to state 22


state 13

    (5) quantifiedstep -> ATLEASTONE step .

    OPTION          reduce using rule 5 (quantifiedstep -> ATLEASTONE step .)
    ATLEASTONE      reduce using rule 5 (quantifiedstep -> ATLEASTONE step .)
    ANY             reduce using rule 5 (quantifiedstep -> ATLEASTONE step .)
    NOT             reduce using rule 5 (quantifiedstep -> ATLEASTONE step .)
    LBRACKET        reduce using rule 5 (quantifiedstep -> ATLEASTONE step .)
    NAME            reduce using rule 5 (quantifiedstep -> ATLEASTONE step .)
    $end            reduce using rule 5 (quantifiedstep -> ATLEASTONE step .)


state 14

    (9) step -> LBRACKET classconstraint . RBRACKET

    RBRACKET        shift and go to state 23


state 15

    (14) partofclassconstraint -> LPAREN . classconstraint RPAREN
    (10) classconstraint -> . partofclassconstraint
    (11) classconstraint -> . partofclassconstraint AND classconstraint
    (12) classconstraint -> . partofclassconstraint OR classconstraint
    (13) partofclassconstraint -> . atomicconstraint
    (14) partofclassconstraint -> . LPAREN classconstraint RPAREN
    (15) partofclassconstraint -> . NOT classconstraint
    (16) atomicconstraint -> . NAME IS VALUE

    LPAREN          shift and go to state 15
    NOT             shift and go to state 18
    NAME            shift and go to state 4

    classconstraint                shift and go to state 24
    atomicconstraint               shift and go to state 16
    partofclassconstraint          shift and go to state 17

state 16

    (13) partofclassconstraint -> atomicconstraint .

    AND             reduce using rule 13 (partofclassconstraint -> atomicconstraint .)
    OR              reduce using rule 13 (partofclassconstraint -> atomicconstraint .)
    RBRACKET        reduce using rule 13 (partofclassconstraint -> atomicconstraint .)
    RPAREN          reduce using rule 13 (partofclassconstraint -> atomicconstraint .)


state 17

    (10) classconstraint -> partofclassconstraint .
    (11) classconstraint -> partofclassconstraint . AND classconstraint
    (12) classconstraint -> partofclassconstraint . OR classconstraint

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RBRACKET        reduce using rule 10 (classconstraint -> partofclassconstraint .)
    RPAREN          reduce using rule 10 (classconstraint -> partofclassconstraint .)
    AND             shift and go to state 26
    OR              shift and go to state 25

  ! AND             [ reduce using rule 10 (classconstraint -> partofclassconstraint .) ]
  ! OR              [ reduce using rule 10 (classconstraint -> partofclassconstraint .) ]


state 18

    (15) partofclassconstraint -> NOT . classconstraint
    (10) classconstraint -> . partofclassconstraint
    (11) classconstraint -> . partofclassconstraint AND classconstraint
    (12) classconstraint -> . partofclassconstraint OR classconstraint
    (13) partofclassconstraint -> . atomicconstraint
    (14) partofclassconstraint -> . LPAREN classconstraint RPAREN
    (15) partofclassconstraint -> . NOT classconstraint
    (16) atomicconstraint -> . NAME IS VALUE

    LPAREN          shift and go to state 15
    NOT             shift and go to state 18
    NAME            shift and go to state 4

    classconstraint                shift and go to state 27
    atomicconstraint               shift and go to state 16
    partofclassconstraint          shift and go to state 17

state 19

    (1) expression -> quantifiedstep expression .

    $end            reduce using rule 1 (expression -> quantifiedstep expression .)


state 20

    (4) quantifiedstep -> OPTION step .

    OPTION          reduce using rule 4 (quantifiedstep -> OPTION step .)
    ATLEASTONE      reduce using rule 4 (quantifiedstep -> OPTION step .)
    ANY             reduce using rule 4 (quantifiedstep -> OPTION step .)
    NOT             reduce using rule 4 (quantifiedstep -> OPTION step .)
    LBRACKET        reduce using rule 4 (quantifiedstep -> OPTION step .)
    NAME            reduce using rule 4 (quantifiedstep -> OPTION step .)
    $end            reduce using rule 4 (quantifiedstep -> OPTION step .)


state 21

    (8) step -> NOT step .

    OPTION          reduce using rule 8 (step -> NOT step .)
    ATLEASTONE      reduce using rule 8 (step -> NOT step .)
    ANY             reduce using rule 8 (step -> NOT step .)
    NOT             reduce using rule 8 (step -> NOT step .)
    LBRACKET        reduce using rule 8 (step -> NOT step .)
    NAME            reduce using rule 8 (step -> NOT step .)
    $end            reduce using rule 8 (step -> NOT step .)


state 22

    (16) atomicconstraint -> NAME IS VALUE .

    AND             reduce using rule 16 (atomicconstraint -> NAME IS VALUE .)
    OR              reduce using rule 16 (atomicconstraint -> NAME IS VALUE .)
    RBRACKET        reduce using rule 16 (atomicconstraint -> NAME IS VALUE .)
    RPAREN          reduce using rule 16 (atomicconstraint -> NAME IS VALUE .)
    OPTION          reduce using rule 16 (atomicconstraint -> NAME IS VALUE .)
    ATLEASTONE      reduce using rule 16 (atomicconstraint -> NAME IS VALUE .)
    ANY             reduce using rule 16 (atomicconstraint -> NAME IS VALUE .)
    NOT             reduce using rule 16 (atomicconstraint -> NAME IS VALUE .)
    LBRACKET        reduce using rule 16 (atomicconstraint -> NAME IS VALUE .)
    NAME            reduce using rule 16 (atomicconstraint -> NAME IS VALUE .)
    $end            reduce using rule 16 (atomicconstraint -> NAME IS VALUE .)


state 23

    (9) step -> LBRACKET classconstraint RBRACKET .

    OPTION          reduce using rule 9 (step -> LBRACKET classconstraint RBRACKET .)
    ATLEASTONE      reduce using rule 9 (step -> LBRACKET classconstraint RBRACKET .)
    ANY             reduce using rule 9 (step -> LBRACKET classconstraint RBRACKET .)
    NOT             reduce using rule 9 (step -> LBRACKET classconstraint RBRACKET .)
    LBRACKET        reduce using rule 9 (step -> LBRACKET classconstraint RBRACKET .)
    NAME            reduce using rule 9 (step -> LBRACKET classconstraint RBRACKET .)
    $end            reduce using rule 9 (step -> LBRACKET classconstraint RBRACKET .)


state 24

    (14) partofclassconstraint -> LPAREN classconstraint . RPAREN

    RPAREN          shift and go to state 28


state 25

    (12) classconstraint -> partofclassconstraint OR . classconstraint
    (10) classconstraint -> . partofclassconstraint
    (11) classconstraint -> . partofclassconstraint AND classconstraint
    (12) classconstraint -> . partofclassconstraint OR classconstraint
    (13) partofclassconstraint -> . atomicconstraint
    (14) partofclassconstraint -> . LPAREN classconstraint RPAREN
    (15) partofclassconstraint -> . NOT classconstraint
    (16) atomicconstraint -> . NAME IS VALUE

    LPAREN          shift and go to state 15
    NOT             shift and go to state 18
    NAME            shift and go to state 4

    classconstraint                shift and go to state 29
    atomicconstraint               shift and go to state 16
    partofclassconstraint          shift and go to state 17

state 26

    (11) classconstraint -> partofclassconstraint AND . classconstraint
    (10) classconstraint -> . partofclassconstraint
    (11) classconstraint -> . partofclassconstraint AND classconstraint
    (12) classconstraint -> . partofclassconstraint OR classconstraint
    (13) partofclassconstraint -> . atomicconstraint
    (14) partofclassconstraint -> . LPAREN classconstraint RPAREN
    (15) partofclassconstraint -> . NOT classconstraint
    (16) atomicconstraint -> . NAME IS VALUE

    LPAREN          shift and go to state 15
    NOT             shift and go to state 18
    NAME            shift and go to state 4

    classconstraint                shift and go to state 30
    atomicconstraint               shift and go to state 16
    partofclassconstraint          shift and go to state 17

state 27

    (15) partofclassconstraint -> NOT classconstraint .

    AND             reduce using rule 15 (partofclassconstraint -> NOT classconstraint .)
    OR              reduce using rule 15 (partofclassconstraint -> NOT classconstraint .)
    RBRACKET        reduce using rule 15 (partofclassconstraint -> NOT classconstraint .)
    RPAREN          reduce using rule 15 (partofclassconstraint -> NOT classconstraint .)


state 28

    (14) partofclassconstraint -> LPAREN classconstraint RPAREN .

    AND             reduce using rule 14 (partofclassconstraint -> LPAREN classconstraint RPAREN .)
    OR              reduce using rule 14 (partofclassconstraint -> LPAREN classconstraint RPAREN .)
    RBRACKET        reduce using rule 14 (partofclassconstraint -> LPAREN classconstraint RPAREN .)
    RPAREN          reduce using rule 14 (partofclassconstraint -> LPAREN classconstraint RPAREN .)


state 29

    (12) classconstraint -> partofclassconstraint OR classconstraint .

    AND             reduce using rule 12 (classconstraint -> partofclassconstraint OR classconstraint .)
    OR              reduce using rule 12 (classconstraint -> partofclassconstraint OR classconstraint .)
    RBRACKET        reduce using rule 12 (classconstraint -> partofclassconstraint OR classconstraint .)
    RPAREN          reduce using rule 12 (classconstraint -> partofclassconstraint OR classconstraint .)


state 30

    (11) classconstraint -> partofclassconstraint AND classconstraint .

    AND             reduce using rule 11 (classconstraint -> partofclassconstraint AND classconstraint .)
    OR              reduce using rule 11 (classconstraint -> partofclassconstraint AND classconstraint .)
    RBRACKET        reduce using rule 11 (classconstraint -> partofclassconstraint AND classconstraint .)
    RPAREN          reduce using rule 11 (classconstraint -> partofclassconstraint AND classconstraint .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for AND in state 17 resolved as shift
WARNING: shift/reduce conflict for OR in state 17 resolved as shift
