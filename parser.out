Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    ANY
    ATLEASTONE
    OPTION

Grammar

Rule 0     S' -> step
Rule 1     step -> atomicconstraint
Rule 2     step -> NOT step
Rule 3     step -> LBRACKET classconstraint RBRACKET
Rule 4     classconstraint -> classconstraint AND partofclassconstraint
Rule 5     classconstraint -> classconstraint OR partofclassconstraint
Rule 6     classconstraint -> partofclassconstraint
Rule 7     partofclassconstraint -> atomicconstraint
Rule 8     partofclassconstraint -> LPAREN classconstraint RPAREN
Rule 9     partofclassconstraint -> NOT classconstraint
Rule 10    atomicconstraint -> NAME EQ VALUE
Rule 11    atomicconstraint -> NAME MATCH VALUE
Rule 12    atomicconstraint -> NAME IN VALUE

Terminals, with rules where they appear

AND                  : 4
ANY                  : 
ATLEASTONE           : 
EQ                   : 10
IN                   : 12
LBRACKET             : 3
LPAREN               : 8
MATCH                : 11
NAME                 : 10 11 12
NOT                  : 2 9
OPTION               : 
OR                   : 5
RBRACKET             : 3
RPAREN               : 8
VALUE                : 10 11 12
error                : 

Nonterminals, with rules where they appear

atomicconstraint     : 1 7
classconstraint      : 3 4 5 8 9
partofclassconstraint : 4 5 6
step                 : 2 0

Parsing method: LALR

state 0

    (0) S' -> . step
    (1) step -> . atomicconstraint
    (2) step -> . NOT step
    (3) step -> . LBRACKET classconstraint RBRACKET
    (10) atomicconstraint -> . NAME EQ VALUE
    (11) atomicconstraint -> . NAME MATCH VALUE
    (12) atomicconstraint -> . NAME IN VALUE

    NOT             shift and go to state 4
    LBRACKET        shift and go to state 5
    NAME            shift and go to state 1

    step                           shift and go to state 2
    atomicconstraint               shift and go to state 3

state 1

    (10) atomicconstraint -> NAME . EQ VALUE
    (11) atomicconstraint -> NAME . MATCH VALUE
    (12) atomicconstraint -> NAME . IN VALUE

    EQ              shift and go to state 8
    MATCH           shift and go to state 6
    IN              shift and go to state 7


state 2

    (0) S' -> step .



state 3

    (1) step -> atomicconstraint .

    $end            reduce using rule 1 (step -> atomicconstraint .)


state 4

    (2) step -> NOT . step
    (1) step -> . atomicconstraint
    (2) step -> . NOT step
    (3) step -> . LBRACKET classconstraint RBRACKET
    (10) atomicconstraint -> . NAME EQ VALUE
    (11) atomicconstraint -> . NAME MATCH VALUE
    (12) atomicconstraint -> . NAME IN VALUE

    NOT             shift and go to state 4
    LBRACKET        shift and go to state 5
    NAME            shift and go to state 1

    step                           shift and go to state 9
    atomicconstraint               shift and go to state 3

state 5

    (3) step -> LBRACKET . classconstraint RBRACKET
    (4) classconstraint -> . classconstraint AND partofclassconstraint
    (5) classconstraint -> . classconstraint OR partofclassconstraint
    (6) classconstraint -> . partofclassconstraint
    (7) partofclassconstraint -> . atomicconstraint
    (8) partofclassconstraint -> . LPAREN classconstraint RPAREN
    (9) partofclassconstraint -> . NOT classconstraint
    (10) atomicconstraint -> . NAME EQ VALUE
    (11) atomicconstraint -> . NAME MATCH VALUE
    (12) atomicconstraint -> . NAME IN VALUE

    LPAREN          shift and go to state 13
    NOT             shift and go to state 10
    NAME            shift and go to state 1

    atomicconstraint               shift and go to state 14
    classconstraint                shift and go to state 11
    partofclassconstraint          shift and go to state 12

state 6

    (11) atomicconstraint -> NAME MATCH . VALUE

    VALUE           shift and go to state 15


state 7

    (12) atomicconstraint -> NAME IN . VALUE

    VALUE           shift and go to state 16


state 8

    (10) atomicconstraint -> NAME EQ . VALUE

    VALUE           shift and go to state 17


state 9

    (2) step -> NOT step .

    $end            reduce using rule 2 (step -> NOT step .)


state 10

    (9) partofclassconstraint -> NOT . classconstraint
    (4) classconstraint -> . classconstraint AND partofclassconstraint
    (5) classconstraint -> . classconstraint OR partofclassconstraint
    (6) classconstraint -> . partofclassconstraint
    (7) partofclassconstraint -> . atomicconstraint
    (8) partofclassconstraint -> . LPAREN classconstraint RPAREN
    (9) partofclassconstraint -> . NOT classconstraint
    (10) atomicconstraint -> . NAME EQ VALUE
    (11) atomicconstraint -> . NAME MATCH VALUE
    (12) atomicconstraint -> . NAME IN VALUE

    LPAREN          shift and go to state 13
    NOT             shift and go to state 10
    NAME            shift and go to state 1

    atomicconstraint               shift and go to state 14
    classconstraint                shift and go to state 18
    partofclassconstraint          shift and go to state 12

state 11

    (3) step -> LBRACKET classconstraint . RBRACKET
    (4) classconstraint -> classconstraint . AND partofclassconstraint
    (5) classconstraint -> classconstraint . OR partofclassconstraint

    RBRACKET        shift and go to state 21
    AND             shift and go to state 20
    OR              shift and go to state 19


state 12

    (6) classconstraint -> partofclassconstraint .

    RPAREN          reduce using rule 6 (classconstraint -> partofclassconstraint .)
    AND             reduce using rule 6 (classconstraint -> partofclassconstraint .)
    OR              reduce using rule 6 (classconstraint -> partofclassconstraint .)
    RBRACKET        reduce using rule 6 (classconstraint -> partofclassconstraint .)


state 13

    (8) partofclassconstraint -> LPAREN . classconstraint RPAREN
    (4) classconstraint -> . classconstraint AND partofclassconstraint
    (5) classconstraint -> . classconstraint OR partofclassconstraint
    (6) classconstraint -> . partofclassconstraint
    (7) partofclassconstraint -> . atomicconstraint
    (8) partofclassconstraint -> . LPAREN classconstraint RPAREN
    (9) partofclassconstraint -> . NOT classconstraint
    (10) atomicconstraint -> . NAME EQ VALUE
    (11) atomicconstraint -> . NAME MATCH VALUE
    (12) atomicconstraint -> . NAME IN VALUE

    LPAREN          shift and go to state 13
    NOT             shift and go to state 10
    NAME            shift and go to state 1

    atomicconstraint               shift and go to state 14
    classconstraint                shift and go to state 22
    partofclassconstraint          shift and go to state 12

state 14

    (7) partofclassconstraint -> atomicconstraint .

    AND             reduce using rule 7 (partofclassconstraint -> atomicconstraint .)
    OR              reduce using rule 7 (partofclassconstraint -> atomicconstraint .)
    RBRACKET        reduce using rule 7 (partofclassconstraint -> atomicconstraint .)
    RPAREN          reduce using rule 7 (partofclassconstraint -> atomicconstraint .)


state 15

    (11) atomicconstraint -> NAME MATCH VALUE .

    AND             reduce using rule 11 (atomicconstraint -> NAME MATCH VALUE .)
    OR              reduce using rule 11 (atomicconstraint -> NAME MATCH VALUE .)
    RBRACKET        reduce using rule 11 (atomicconstraint -> NAME MATCH VALUE .)
    RPAREN          reduce using rule 11 (atomicconstraint -> NAME MATCH VALUE .)
    $end            reduce using rule 11 (atomicconstraint -> NAME MATCH VALUE .)


state 16

    (12) atomicconstraint -> NAME IN VALUE .

    AND             reduce using rule 12 (atomicconstraint -> NAME IN VALUE .)
    OR              reduce using rule 12 (atomicconstraint -> NAME IN VALUE .)
    RBRACKET        reduce using rule 12 (atomicconstraint -> NAME IN VALUE .)
    RPAREN          reduce using rule 12 (atomicconstraint -> NAME IN VALUE .)
    $end            reduce using rule 12 (atomicconstraint -> NAME IN VALUE .)


state 17

    (10) atomicconstraint -> NAME EQ VALUE .

    AND             reduce using rule 10 (atomicconstraint -> NAME EQ VALUE .)
